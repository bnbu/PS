#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>
using namespace std;

int n;
vector<vector<int>> d;
vector<int> memo;
int bit_cnt(int bit) {
    int ret = 0;
    for (int i = 0; i < n; i++)
        if (bit & (1 << i)) ret++;
    
    return ret;
}
int main() {
    ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

    cin >> n;
    d = vector<vector<int>>(n);
    memo = vector<int>((1 << n), INT32_MAX);
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < n; j++)  {
            int a;
            cin >> a;
            d[i].push_back(a);
        }

    memo[0] = 0;
    for (int i = 0; i < (1 << n) - 1; i++) {
        int cnt = bit_cnt(i);
        for (int j = 0; j < n; j++)
            memo[i | (1 << j)] = min(memo[i | (1 << j)], memo[i] + d[cnt][j]);
    }
    cout << memo[(1 << n) - 1];
    return 0;
}
// 2021-08-10 해결
// 비트마스크를 이용한 dp연습

// N x N 행렬이 주어져서
// d[i][j]가 의미하는 것은, i번째 사람이 j번째 일을 하는데 드는 비용
// 그리고 한 사람당 하나의 일만 할당할 수 있을때, 모든 일을 수행하는데 드는 최소비용을 구하는 문제

// 단적으로 나이브하게 풀어버리면, 그냥 존재할 수 있는 모든 순열중 최소를 구해버리면 된다
// 하지만 이럴 경우, 순열이기 때문에 N!의 경우의 수가 발생하고 이는 곧 O(N!)이 되어버린다

// 이를 비트마스크를 사용하면 시간을 줄여볼 수 있는데,

// 아이디어는 다음과 같다.
// N비트짜리 정수가 있다고 하자.
// 각 비트는 각 사람들이 일을 배정 받았는지 안받았는지 유무를 뜻한다.
// 그리고 지금 몇개의 비트가 추가되었는지는, 앞으로 몇번째 일이 배정될지를 의미한다.
// 이를 0부터 2^N - 1까지 를 살펴보면
// 존재할 수 있는 모든 경우의 수를 살펴보게 된다.

// 순서는 고려하지 않았을 수도 있지만, 단적으로 가장 마지막의 경우를 살펴보면
// 가장 마지막은 모든 비트가 1인, 즉 모두 일을 받은 후의 경우다

// N = 5일때의 예시로 보면,
// 11111(2) 상태의 최솟값은 01111, 10111, 11011, 11101, 11110 이 5가지중에서 살펴보게 될 것이며
// 다시 01111(2)의 상태의 최솟값은 00111, 01011, 01101, 01110
// 다시 00111(2)는 00011, 00101, 00110
// 다시 00011(2)는 00001, 00010

// 이를 바텀업 방식으로 생각해보면
// 처음 00000(2)에서 1개의 비트를 추가시켰을 경우의 최솟값을 각각 생각해보면
// 00000(2) => 10000, 01000, 00100, 00010, 00001 이 5가지의 경우에 대한 최솟값을 계산해둘 것이다
// 그 다음 10000(2) => 11000, 10100, 10010, 1000 등의 방식..
// 보면 알겠지만, 비트가 추가될수록 살펴보게 될 갯수가 점점 줄어들게 된다.
// 계산해보면 나오겠지만 당연하게도 N! 보다는 적은 경우의 수가 된다.

// 여기서 0 ~ 2^N - 1 까지 살펴보게 된다면, 모든 경우의 수를 살펴보게 되고
// 최종적으로는 최솟값을 살펴보게 되는 것.

// 이를 수식으로 표현시켜보면

// **(i는 0부터 2^n - 2까지 모두 살펴볼 것 이다, 왜 -2까지냐면, 1까지면 모두 배정이 끝난 상황이니까)
// 현재 비트값이 i일때, 비트의 개수를 cnt개라고 하면
// 다음의 배정할 일은 cnt번째 일이 된다 (** 0번째부터 시작한다고 생각할때 기준)
// 따라서, j번째 사람이 cnt번째 일을 배정받을 경우의 최솟값을 계산하게 되므로
// memo[i || (1 << j)] = min(memo[i || (1 << j)], memo[i] + d[cnt][j]) 
// 이것의 의미를 풀어서 보면
// 현재 비트의 개수가 cnt이고, 비트값이 i일때
// j번째 사람이 cnt번째 일을 한다고 하면
// i에서 j번째 비트를 활성화 시킨 memo[i || (1 << j)] 값은 memo[i] + d[cnt][j]가 된다.
// 최솟값을 계산해야하니 min함수로 비교.